# Introduction #

Previous work has already shown that Avro serialization is reasonably fast: http://wiki.github.com/eishay/jvm-serializers/

The point of this page is to show the performance of records generated by the plugin, with (Java) records generated by the stock Avro compiler

# Graphs #

The full benchmark code can be found at: http://code.google.com/p/avro-scala-compiler-plugin/source/browse/#svn/trunk/benchmarks. To run the test on your own machine, simply type `mvn scala:run -DmainClass=benchmarks.Benchmark` in the `benchmarks` directory.

In the benchmark tests, we profile five different record types, and compare the time to serialize/deserialize them. For our serialization tests, we assume the object already exists (so we measure the time to take a constructed object and create a byte array). For our deserialization tests, we assume the byte array exists (so we measure the time to take a byte array and create the object in question).

For a baseline comparison, we also include the results of using Java serialization in the graphs.

## Record composed of only primitives ##
The plugin definition/initialization:
```
case class Primitives(var i: Int, var j: Long, var k: Boolean) extends AvroRecord
```
```
Primitives(10000, 100000L, true)
```
The Avro definition/initialization:
```
  {
    "name" : "Primitives",
    "type" : "record",
    "fields" : [
      { "name" : "i", "type" : "int" },
      { "name" : "j", "type" : "long" },
      { "name" : "k", "type" : "boolean" }
    ]
  }
```
```
val r = new Primitives
r.i = 10000
r.j = 100000L
r.k = true
```
The Java definition/initialization:
```
case class Primitives(i: Int, j: Long, k: Boolean)
```
```
Primitives(10000, 100000L, true)
```
<img src='http://cs.berkeley.edu/~sltu/primitives.png' />

## Record holding sequences of primitives ##
The plugin definition/initialization:
```
case class SeqOfPrimitives(var i: Seq[Int], var j: Seq[Long]) extends AvroRecord
```
```
SeqOfPrimitives((1 to 10).map(i => i).toSeq, (1L to 100L).map(i => i).toSeq)
```
The Avro definition/initialization:
```
  {
    "name" : "ArrayOfPrimitives",
    "type" : "record",
    "fields" : [
      { "name" : "i", "type" : { "type" : "array", "items" : "int" } },
      { "name" : "j", "type" : { "type" : "array", "items" : "long" } }
    ]
  }
```
```
import java.lang.{ Integer => JInteger, Long => JLong }
val r = new ArrayOfPrimitives
val i = new GenericData.Array[JInteger](10, r.getSchema.getField("i").schema)
val j = new GenericData.Array[JLong](100, r.getSchema.getField("j").schema)

for (e <- 1 to 10) { i.add(e) }
for (e <- 1L to 100L) { j.add(e) }

r.i = i
r.j = j
```
The Java definition/initialization:
```
case class SeqOfPrimitives(i: Seq[Int], j: Seq[Long])
```
```
SeqOfPrimitives((1 to 10).map(i => i).toSeq, (1L to 100L).map(i => i).toSeq)
```
<img src='http://cs.berkeley.edu/~sltu/seqprimitives.png' />

## Record containing a byte array ##
The plugin definition/initialization:
```
case class ByteContainer(var i: Array[Byte]) extends AvroRecord
```
```
ByteContainer((1 to 1024).map(_.toByte).toArray)
```
The Avro definition/initialization:
```
  {
    "name" : "ByteContainer",
    "type" : "record",
    "fields" : [ { "name" : "i", "type" : "bytes" } ]
  }
```
```
val r = new ByteContainer
r.i = ByteBuffer.wrap((1 to 1024).map(_.toByte).toArray)
```
The Java definition/initialization:
```
case class ByteContainer(i: Array[Byte])
```
```
ByteContainer((1 to 1024).map(_.toByte).toArray)
```
<img src='http://cs.berkeley.edu/~sltu/bytecontainer.png' />

## Record containing records ##
The plugin definition/initialization:
```
case class MessageContainer(var i: InnerMessage1, var j: InnerMessage2) extends AvroRecord
case class InnerMessage1(var i: Float) extends AvroRecord
case class InnerMessage2(var i: Double) extends AvroRecord
```
```
MessageContainer(InnerMessage1(1.0f), InnerMessage2(-1.0))
```
The Avro definition/initialization:
```
  {
    "name" : "InnerMessage1",
    "type" : "record",
    "fields" : [ { "name" : "i", "type" : "float" } ]
  },
  {
    "name" : "InnerMessage2",
    "type" : "record",
    "fields" : [ { "name" : "i", "type" : "double" } ]
  },
  {
    "name" : "MessageContainer",
    "type" : "record",
    "fields" : [
      { "name" : "i", "type" : "InnerMessage1" },
      { "name" : "j", "type" : "InnerMessage2" }
    ]
  }
```
```
val r = new MessageContainer
val i = new InnerMessage1
i.i   = 1.0f
val j = new InnerMessage2
j.i   = -1.0
r.i   = i
r.j   = j
```
The Java definition/initialization:
```
case class MessageContainer(i: InnerMessage1, j: InnerMessage2)
case class InnerMessage1(i: Float)
case class InnerMessage2(i: Double)
```
```
MessageContainer(InnerMessage1(1.0f), InnerMessage2(-1.0))
```
<img src='http://www.cs.berkeley.edu/~sltu/messagecontainer.png' />

## Records containing list of records ##
The plugin definition/initialization:
```
case class RecordList(var i: List[StringRec]) extends AvroRecord
case class StringRec(var i: Utf8) extends AvroRecord
```
```
RecordList((1 to 128).map(i => StringRec(new Utf8(i.toString))).toList)
```
The Avro definition/initialization:
```
  {
    "name" : "StringRec",
    "type" : "record",
    "fields" : [ { "name" : "i", "type" : "string" } ]
  },
  {
    "name" : "RecordList",
    "type" : "record",
    "fields" : [
      { "name" : "i", "type" : { "type": "array", "items" : "StringRec" } }
    ]
  }
```
```
val r = new RecordList
r.i   = new GenericData.Array[StringRec](128, r.getSchema.getField("i").schema)
for (i <- 1 to 128) {
  val sr = new StringRec
  sr.i   = new Utf8(i.toString)
  r.i.add(sr)
}
```
The Java definition/initialization:
```
case class RecordList(i: List[StringRec])
case class StringRec(i: String) // String used because Utf8 is not Java serializable
```
```
RecordList((1 to 128).map(i => StringRec(i.toString)).toList)
```
<img src='http://www.cs.berkeley.edu/~sltu/recordlist.png' />